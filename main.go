package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// Weekend: finish and test the components built so far: prop type replacement and dispatch/state map inserts

//Requirements

// separate template files for each type of replacements
// Well documented

// for generating flow props - add in basic if not found. Also check for state and add in if not found.
// If default props present and line item not present in props, add to props.
// If action not present in proptypes, add to props.
// if mapstatetoprops not present in proptypes, add to props.

// For generating actions, must look through for connect. If not found, add it in (plus imports and mapstatetoprops and export). If it is there, then check mapdispatchtoprops sub items.

// For generating reducers, look through for same action names plus the suffix Reducer. Add any not found
// Then look through the combined reducer for the reducers. Add any not found

// To mark an action as custom (and not able to be generated), prefix it with //@NoGen
// To mark a file as custom (and not able to be generated), put //@NoGenFile in the file somewhere
// Change the template if you want the custom tags (generated by, etc)

// template is passed variable types for each action and the action names - otherwise same format as gogen/yacc

// example tags
// Generated by GoReactGen

// End generated code

// separate function that generates flow type from json or from a go struct (with json annotations)
// definitely dont change functions if they use an import
func check(e error) {
	if e != nil {
		panic(e)
	}
}

var typeDict = map[string]string{
	"undefined": `\s*(undefined),?\s*`,
	"null":      `\s*(null),?\s*`,
	"float":     `^\s*[+-]?[0-9]*[\.][0-9]+,?\s*$`,
	"number":    `^\s*[+-]?[0-9]+,?\s*$`,
	"array":     `\s*\[\s*`,
	"arrayEnd":  `\s*\],?\s*`,
	"object":    `\s*[\{\}],?\s*`,
	"string":    `["'].*["'],?`,
}
var javascriptDict = map[string]string{
	// First empty line after all imports
	"afterImport": `(?:import.*?)([\r\n])`,
	"afterFlow":   `(@flow.*?)`,
}

var file string

// todo change all splits to regex - so we can get the closing brackets correctly
// TODO insert React.Component<Props> and State
// TODO: relies on types being before actioncreators - good practice anyways
func parseObject(path string, firstMarker string, lastMarker string, spacer string) ([]string, error) {
	var lines []string

	contents, err := ioutil.ReadFile(path)
	check(err)
	processed := string(contents)
	if !strings.Contains(processed, firstMarker) {
		return lines, errors.New("No firstMarker found")
	}
	processedSplit := strings.SplitAfter(processed, firstMarker)

	processedFirst := strings.SplitAfter(processedSplit[1], lastMarker)
	processedLast := strings.SplitAfter(processedFirst[0], "\n")

	for _, line := range processedLast {
		if strings.Contains(line, lastMarker) {
			break
		} else {
			lines = append(lines, strings.SplitAfter(strings.SplitAfter(line, spacer)[0], ":")[0])
		}
	}

	return lines, nil
}

// maybe just operate on an index?

func parseObjectValues(path string, firstMarker string, lastMarker string, spacer string, replacer func(string, bool) string) (string, error) {
	contents, err := ioutil.ReadFile(path)
	check(err)
	processed := string(contents)
	if !strings.Contains(processed, firstMarker) {
		return "", errors.New("No firstMarker found")
	}
	processedSplit := strings.SplitAfter(processed, firstMarker)

	processedFirst := strings.SplitAfter(processedSplit[1], lastMarker)
	processedLast := strings.SplitAfter(processedFirst[0], "\n")

	for index, line := range processedLast {
		if line == (spacer + lastMarker) {
			fmt.Println("Ended on :" + line + "Due to: " + spacer + lastMarker)
			break
		} else {
			value := strings.SplitAfter(line, ":")
			if len(value) > 1 {
				value[1] = replacer(value[1], true)
				processedLast[index] = strings.Join(value, "")
			} else {
				value[0] = replacer(value[0], false)
				processedLast[index] = strings.Join(value, "")
			}
		}
	}

	// join string up again
	file := strings.Join(processedLast, "")

	return file, nil
}

// TODO: relies on types being before actioncreators - good practice anyways
func parseActions(path string, config configuration) ([]string, []string, []string, error) {
	var actions []string
	var types []string
	var APITypes []string

	contents, err := ioutil.ReadFile(path)
	check(err)
	processed := string(contents)

	if !strings.Contains(processed, config.actionCreatorMarker) {
		return types, APITypes, actions, errors.New("No actionCreator found")
	}
	processedSplit := strings.SplitAfter(processed, config.actionCreatorMarker)
	// identifier is every type line until }
	processedTypes := strings.SplitAfter(processedSplit[0], "types = {")
	processedTypes = strings.SplitAfter(processedTypes[1], "\n")

	for _, line := range processedTypes {
		if strings.Contains(line, "}") {
			break
		} else if strings.Contains(line, "_REQUEST") {
			APITypes = append(APITypes, strings.SplitAfter(strings.SplitAfter(line, "'")[1], "_REQUEST")[0])
		} else if strings.Contains(line, "_REPLY") || strings.Contains(line, "_ERROR") {
			continue
		} else if strings.Contains(line, "'") {
			types = append(types, strings.SplitAfter(line, "'")[1])
		}
	}

	// identifier is any line prefixed by 4 spaces (setting and no more)
	// then get name

	processedAC := strings.SplitAfter(processedSplit[1], "\n")
	for _, line := range processedAC {
		regex := regexp.MustCompile("$(" + config.spacer + "){1}")
		processLine := regex.FindIndex([]byte(line))
		if (processLine != nil) && (line != "};\n") {
			actions = append(actions, strings.SplitAfter(strings.SplitAfter(line, config.spacer)[1], ":")[0])
		}
	}

	return types, APITypes, actions, nil
}

func replaceTypes(inputString string, split bool) string {
	input := []byte(inputString)

	regexUndefined := regexp.MustCompile(typeDict["undefined"])
	regexNull := regexp.MustCompile(typeDict["null"])
	regexFloat := regexp.MustCompile(typeDict["float"])
	regexNumber := regexp.MustCompile(typeDict["number"])
	regexArray := regexp.MustCompile(typeDict["array"])
	regexArrayEnd := regexp.MustCompile(typeDict["arrayEnd"])
	regexObject := regexp.MustCompile(typeDict["object"])
	regexString := regexp.MustCompile(typeDict["string"])

	var regexResult [][]int
	end := ""
	if split {
		end = "\n"
	}
	if regexResult = regexUndefined.FindAllIndex(input, -1); regexResult != nil {
		return " undefined," + end
	} else if regexResult = regexNull.FindAllIndex(input, -1); regexResult != nil {
		return " null," + end
	} else if regexResult = regexFloat.FindAllIndex(input, -1); regexResult != nil {
		return " float," + end
	} else if regexResult = regexNumber.FindAllIndex(input, -1); regexResult != nil {
		return " number," + end
	} else if regexResult = regexArray.FindAllIndex(input, -1); regexResult != nil {
		return " Array<"
	} else if regexResult = regexArrayEnd.FindAllIndex(input, -1); regexResult != nil {
		return " >,\n"
	} else if regexResult = regexObject.FindAllIndex(input, -1); regexResult != nil {
		return inputString
	} else if regexResult = regexString.FindAllIndex(input, -1); regexResult != nil {
		return " string," + end
	}
	return inputString
}

func propTypesGenerator(path string, config configuration) error {
	isPropTypes := strings.Contains(file, config.propTypesMarker)
	if isPropTypes {
		// Not needed?
		// existingProps, err := parseObject(path, config.propTypesMarker, "}", config.spacer)
		// check(err)
		//insert
	} else {
		// create from scratch
		regex := regexp.MustCompile(javascriptDict["afterImport"])
		loc := regex.FindAllIndex([]byte(file), -1)
		index := loc[len(loc)-1][1]
		snippet, err := parseObjectValues(path, config.defaultPropsMarker, "}", config.spacer, replaceTypes)
		snippet = "\n\ntype PropTypes: {" + snippet + "\n};\n"
		check(err)
		newFile := file[:index] + snippet + file[index:]
		err = ioutil.WriteFile(path, []byte(newFile), 0644)
		check(err)
		file = newFile
	}
	return nil
}
func stateTypesGenerator(path string, config configuration) error {
	isStateTypes := strings.Contains(file, config.stateTypesMarker)
	if isStateTypes {
		// not needed?
		// existingStates, err := parseObject(path, config.stateTypesMarker, "}", config.spacer)
		// check(err)
		//insert
	} else {
		// create from scratch
		regex := regexp.MustCompile(javascriptDict["afterImport"])
		loc := regex.FindAllIndex([]byte(file), -1)
		index := loc[len(loc)-1][1]
		snippet, err := parseObjectValues(path, config.stateMarker, "}", config.spacer, replaceTypes)
		snippet = "\ntype StateTypes: {" + snippet + "\n};\n"
		check(err)
		newFile := file[:index] + snippet + file[index:]
		err = ioutil.WriteFile(path, []byte(newFile), 0644)
		check(err)
		file = newFile
	}
	return nil
}
func mapDispatchGenerator(path string, config configuration) error {
	isMapDispatch := strings.Contains(file, config.mapDispatchMarker)
	if !isMapDispatch {
		newFile := file + "\nconst mapDispatchToProps = {\n...actionCreators,\n};\n"
		err := ioutil.WriteFile(path, []byte(newFile), 0644)
		check(err)
		file = newFile
	}
	return nil
}
func blankMapStateGenerator(path string, config configuration) error {
	isMapState := strings.Contains(file, config.mapStateMarker)
	if !isMapState {
		newFile := file + "\nconst mapStateToProps = (state) => ({\n});\n"
		err := ioutil.WriteFile(path, []byte(newFile), 0644)
		check(err)
		file = newFile
	}
	return nil
}
func connectorGenerator(path string, config configuration) error {
	isConnector := strings.Contains(file, config.connectorMarker)
	if !isConnector {
		regex := regexp.MustCompile(javascriptDict["afterFlow"])
		loc := regex.FindAllIndex([]byte(file), -1)
		index := loc[len(loc)-1][1]
		newFile := file[:index] + "\nimport {connect} from 'react-redux';" + file[index:] + "\nexport default connect(\n" + config.spacer + "mapStateToProps,\n" + config.spacer + "mapDispatchToProps,\n)(ComponentName);\n"
		err := ioutil.WriteFile(path, []byte(newFile), 0644)
		check(err)
		file = newFile
	}
	return nil
}
func reducerGenerator(path string, generateReducerFile bool, isReducerExist bool, config configuration, types, APItypes, actions []string) error {
	// Check if any existing reducers in the reducers file and then execute logic
	if generateReducerFile {

	} else if isReducerExist {
		file, err := ioutil.ReadFile(path)
		check(err)
		fmt.Println(file)
	}
	return nil
}
func combinedReducerGenerator(path string, config configuration) error {
	// Check if combined reducers exists in the reducers file and then execute logic
	return nil
}

type configuration struct {
	connectorMarker     string
	spacer              string
	actionCreatorMarker string
	reactMarker         string
	flowMarker          string
	stateMarker         string
	stateTypesMarker    string
	propTypesMarker     string
	defaultPropsMarker  string
	reduxMarker         string
	mapDispatchMarker   string
	mapStateMarker      string
	actionPrefix        string
	actionSuffix        string
	reducerPrefix       string
	reducerSuffix       string
	fileExtension       string
}

func main() {
	dir, err := os.Getwd()
	check(err)

	fmt.Println(dir)

	searchDir := dir

	generatePropTypes := true
	generateStateTypes := true
	generateMapDispatch := true
	generateBlankMapState := true
	generateConnector := true

	generateReducers := false
	generateReducerFile := false
	generateCombinedReducer := false

	config := configuration{
		connectorMarker:     "export default connect",
		spacer:              "    ",
		actionCreatorMarker: "export const actionCreators = {",
		reactMarker:         "import React from ",
		flowMarker:          "@flow",
		stateMarker:         "state =",
		stateTypesMarker:    "State:",
		propTypesMarker:     "Props:",
		defaultPropsMarker:  "static defaultProps = {",
		reduxMarker:         "react-redux",
		mapDispatchMarker:   "mapDispatchToProps",
		mapStateMarker:      "mapStateToProps",
		actionPrefix:        "",
		actionSuffix:        "Actions",
		reducerPrefix:       "",
		reducerSuffix:       "Reducers",
		fileExtension:       ".js",
	}
	// import markers etc

	fileList := make([]string, 0)
	e := filepath.Walk(searchDir, func(path string, info os.FileInfo, err error) error {
		check(err)
		if info.IsDir() || (!strings.Contains(path, ".js") && !strings.Contains(path, ".jsx")) {
			return nil
		}
		contents, err := ioutil.ReadFile(path)

		check(err)

		processed := string(contents)
		file = processed

		isReact := strings.Contains(processed, config.reactMarker)
		isFlow := strings.Contains(processed, config.flowMarker)
		// isRedux := strings.Contains(processed, config.reduxMarker)

		ActionFile := filepath.Dir(path) + string(os.PathSeparator) + config.actionPrefix + strings.TrimSuffix(info.Name(), config.fileExtension) + config.actionSuffix + config.fileExtension
		_, err = os.Stat(ActionFile)
		isActionExist := err == nil
		ReducerFile := filepath.Dir(path) + string(os.PathSeparator) + config.reducerPrefix + strings.TrimSuffix(info.Name(), config.fileExtension) + config.reducerSuffix + config.fileExtension

		if isFlow && isReact {
			isDefaultProps := strings.Contains(processed, config.defaultPropsMarker)
			isState := strings.Contains(processed, config.stateMarker)

			if generateStateTypes && isState {
				stateTypesGenerator(path, config)
			}
			if generatePropTypes && isDefaultProps {
				propTypesGenerator(path, config)
			}
		}
		if isReact && isActionExist {
			isMapState := strings.Contains(processed, config.mapStateMarker)
			isConnector := strings.Contains(processed, config.connectorMarker)

			if generateMapDispatch {
				mapDispatchGenerator(path, config)
			}
			if generateBlankMapState && !isMapState {
				blankMapStateGenerator(path, config)
			}
			if generateConnector && !isConnector {
				connectorGenerator(path, config)
			}
		}
		if isActionExist {
			types, APItypes, actions, err := parseActions(ActionFile, config)
			check(err)
			_, err = os.Stat(ReducerFile)
			isReducerExist := (err == nil)
			if generateReducers {
				reducerGenerator(ReducerFile, generateReducerFile, isReducerExist, config, types, APItypes, actions)
			}
			_, err = os.Stat(ReducerFile)
			isReducerExist = (err == nil)
			if generateCombinedReducer && isReducerExist {
				combinedReducerGenerator(ReducerFile, config)
			}
		}

		// append to files changed which should be returned
		fileList = append(fileList, path)
		return nil
	})

	if e != nil {
		panic(e)
	}

	for _, file := range fileList {
		fmt.Println(file)
	}
}
